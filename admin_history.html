<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lesson History - Admin Portal - C2 Tennis Academy</title>

  <style>
    html, body { height: 100%; margin: 0; display: flex; flex-direction: column; font-family: Arial, sans-serif; }
    header, footer { background-color: #0c3c78; color: white; text-align: center; padding: 20px; }
    nav { background-color: #092e5e; display: flex; justify-content: center; }
    nav a { color: white; padding: 14px 20px; text-decoration: none; }
    nav a:hover { background-color: #0f4fa0; }
    section { flex: 1; padding: 40px 20px; max-width: 1400px; width: 90%; margin: auto; background: white; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    h2 { color: #0c3c78; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { padding: 8px; border:1px solid #ddd; }
    thead th { background: #0c3c78; color: white; }

/* Styling for Enable Editing and Save All History buttons */
#enable-history-editing-btn,
#save-history-btn {
  background-color: #0c3c78;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  border: none;
  cursor: pointer;
  display: inline-block; /* Keep button width tight around text */
  text-decoration: none; /* Though default for button, good to be explicit */
  font-size: 1rem; /* Match other buttons if necessary, or use existing */
}

#enable-history-editing-btn:hover,
#save-history-btn:hover {
  background-color: #0f4fa0;
}

/* Container for the two buttons */
.history-action-buttons-container {
  display: flex;
  gap: 10px; /* Spacing between buttons */
  margin-bottom: 20px; /* Space below the button group */
  /* flex-wrap: wrap; */ /* Optional: allows buttons to wrap on smaller screens if needed */
}

/* === Global Header & Navigation Styles (Finalized Version) === */
     header {
       background-color: #0c3c78; 
       color: white; 
       padding: 30px 20px; 
       position: relative; 
       text-align: center; 
     }
     .header-content { 
       display: flex; justify-content: center; align-items: center; 
       max-width: 1200px; margin: 0 auto;
       position: relative; 
     }
     .site-title { text-align: center; } 
     .site-title h1 { 
       font-size: 2.2em;    
       margin-top: 0;
       margin-bottom: 0; 
       color: white; 
     } 
     .site-title p { 
       font-size: 1em;    
       margin-top: 0;
       margin-bottom: 0;
       color: #f0f0f0;
     }
     
     .mobile-menu-toggle { display: none; background: none; border: none; color: white; font-size: 28px; cursor: pointer; padding: 5px; }
     nav.main-navigation { background-color: #092e5e; }
     .nav-wrapper-desktop { 
         display: flex; justify-content: center; align-items: center;
         width: 100%; max-width: 1200px; margin: 0 auto; padding: 0 20px; box-sizing: border-box;
     }
     ul.nav-links-desktop { list-style: none; margin: 0; padding: 0; display: flex; }
     ul.nav-links-desktop li a { color: white; padding: 14px 20px; text-decoration: none; display: block; } 
     ul.nav-links-desktop li a:hover { background-color: #0f4fa0; }
     ul.nav-links-desktop li a.highlighted-nav, ul.nav-links-desktop li a.current-page { 
        background-color: #d8f352; color: black; font-weight: bold; border-radius: 5px; 
     }
     ul.nav-links-desktop li a.highlighted-nav:hover, ul.nav-links-desktop li a.current-page:hover { background-color: #c1da3b; }
     
     .auth-buttons-desktop { 
       position: absolute;
       top: 20px; 
       right: 20px; 
       display: flex;
       align-items: center;
       gap: 15px; 
     }
     .auth-buttons-desktop a button, .auth-buttons-desktop button {
       background-color: white; color: #0c3c78; border: none; padding: 10px 20px; 
       border-radius: 5px; font-weight: bold; cursor: pointer;
       transition: all 0.3s ease; white-space: nowrap;
     }
     .auth-buttons-desktop a button:hover, .auth-buttons-desktop button:hover { background-color: #0f4fa0; color: white; }
     .mobile-menu-container {
       display: none; background-color: #092e5e; position: fixed;
       top: 0; left: 0; width: 100%; height: 100%;
       z-index: 1000; padding-top: 20px;
       box-sizing: border-box; overflow-y: auto; text-align: center;
     }
     nav.main-navigation.mobile-menu--open .mobile-menu-container { display: block; }
     .mobile-menu-close {
        display: block; 
        position: absolute; 
        top: 10px; 
        right: 10px; 
        left: auto; 
        bottom: auto; 
        background: none; 
        border: none; 
        color: white; 
        font-size: 28px; 
        cursor: pointer;
        z-index: 10; 
     }
     ul.nav-links-mobile { list-style: none; padding: 0; margin: 50px 0 20px; }
     ul.nav-links-mobile li a {
       color: white; padding: 15px 20px; text-decoration: none; display: block;
       border-bottom: 1px solid #0c3c78;
     }
     ul.nav-links-mobile li:last-child a { border-bottom: none; }
     ul.nav-links-mobile li a:hover { background-color: #0f4fa0; }
     .auth-buttons-mobile { padding: 20px; }
     .auth-buttons-mobile a button, .auth-buttons-mobile button {
       background-color: #d8f352; color: #0c3c78; border: none; padding: 12px 20px;
       border-radius: 5px; font-weight: bold; cursor: pointer; display: block;
       width: 80%; max-width: 250px; margin: 10px auto; box-sizing: border-box;
     }
     .auth-buttons-mobile a button:hover, .auth-buttons-mobile button:hover { background-color: #c1da3b; }
     
     footer { 
        background-color: #0c3c78; color: white; text-align: center; padding: 20px; margin-top:auto; 
     }

     @media (max-width: 768px) {
       body { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; } 
       header { padding: 10px 15px; } 
       .header-content {
         justify-content: space-between; 
         width:100%; 
       }
       .site-title { text-align: left; }
       .site-title h1 { font-size: 1.2em; margin-bottom: 0; }
       .site-title p { display: none; } 
       .mobile-menu-toggle { display: block; }
       .nav-wrapper-desktop { display: none; }
       .auth-buttons-desktop { display: none; } 
       nav.main-navigation { padding: 0; background-color: transparent; }
      h2 {
        margin-bottom: 20px; 
      }
      section {
        padding: 20px 10px; 
      }
    }
ul.nav-links-desktop li a.highlighted-nav {
  border-radius: 9999px;
}
ul.nav-links-mobile li a.highlighted-nav {
  border-radius: 9999px;
}
ul.nav-links-desktop li a {
  border-radius: 9999px;
}
ul.nav-links-desktop li a.highlighted-nav {
  border-radius: 9999px;
}
ul.nav-links-mobile li a {
  border-radius: 9999px;
}

.explore-button {
  font-family: Arial, sans-serif;
  font-size: 1rem;
  font-weight: 400;
  background-color: #3b82f6; 
  color: white !important; 
  padding: 0.75rem 2rem;
  border: none;
  border-radius: 9999px; 
  box-shadow:
    0 10px 15px -3px rgba(0, 0, 0, 0.1),
    0   4px  6px -2px rgba(0, 0, 0, 0.05);
  cursor: pointer;
  transform-origin: center center;
  transition: background-color 0.2s ease, transform 0.2s ease;
  text-decoration: none; 
  display: inline-block; 
  text-align: center;
  margin-top: 30px; 
}

.explore-button:hover {
  background-color: #2563eb; 
  transform: scale(1.05);
  color: white !important;
  text-decoration: none;
}

.category-filter-button {
  background-color: #f0f0f0; 
  color: #333;            
  border: 1px solid #ccc;
  padding: 8px 15px;
  margin: 0 5px 10px 0; 
  border-radius: 5px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s ease, color 0.2s ease;
}
.category-filter-button:hover {
  background-color: #e0e0e0; 
}
.category-filter-button.active-filter-button {
  background-color: #0c3c78; 
  color: white;
  border-color: #0c3c78;
  font-weight: bold;
}
#category-filters-title {
    margin-top: 20px;
    margin-bottom: 10px;
    font-weight: bold;
    color: #0c3c78; 
}
.update-payment-btn {
    background-color: #4CAF50; /* Green */
    color: white;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}
.update-payment-btn:hover {
    background-color: #45a049;
}
.coach-checkbox-list label {
  background-color: #f5f5f5;
  padding: 6px 10px;
  border-radius: 5px;
  cursor: pointer;
}
.coach-checkbox-list label:hover {
  background-color: #e0e0e0;
}
  </style>
</head>
<body>

<header>
  <div class="header-content">
    <div class="site-title">
      <h1>Lesson History</h1> 
      <p>C2 Tennis Academy</p> 
    </div>
    <button class="mobile-menu-toggle" aria-label="Open navigation menu" aria-expanded="false" aria-controls="mainNavigation">
      &#9776; 
    </button>
  </div>
  <div class="auth-buttons-desktop" id="authContainerDesktop">
  </div>
</header>

<nav class="main-navigation" id="mainNavigation">
  <div class="nav-wrapper-desktop"> 
     <ul class="nav-links-desktop">
       <li><a href="index.html">Home</a></li>
       <li><a href="about.html">About</a></li>
       <li><a href="programs.html">Programs</a></li>
       <li><a href="schedule.html">Schedule</a></li>
       <li><a href="contact.html">Contact</a></li>
     </ul>
  </div>
  <div class="mobile-menu-container">
    <button class="mobile-menu-close" aria-label="Close navigation menu">&times;</button>
    <ul class="nav-links-mobile">
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="programs.html">Programs</a></li>
      <li><a href="schedule.html">Schedule</a></li>
      <li><a href="contact.html">Contact</a></li>
    </ul>
    <div class="auth-buttons-mobile" id="authContainerMobile">
    </div>
  </div>
</nav>

  <section>
    <h2>Past Lesson History</h2>
    <div style="margin-bottom: 20px; margin-top: 10px;">
      <label for="historySearchInput" style="margin-right: 10px; font-weight: bold;">Search Past Lessons:</label>
      <input type="text" id="historySearchInput" placeholder="Enter keyword (student, program, coach, email, date)..." style="width: 50%; padding: 8px;">
    </div>
    <div id="category-filters-title">Filters:</div>
    <div id="category-filters" style="margin-bottom: 20px;">
      <button class="category-filter-button active-filter-button" data-category="All">All</button>
      <button class="category-filter-button" data-category="Privates">Private Lessons</button>
      <button class="category-filter-button" data-category="Camps">Camps & Passes</button>
      <button class="category-filter-button" data-category="Clinics">Clinics & Other</button>
    </div>

<!-- New container for the buttons -->
<div class="history-action-buttons-container">
  <button id="enable-history-editing-btn">Enable Editing</button>
  <button id="save-history-btn" disabled>Save All History Changes</button>
</div>
    
    <div id="past-lessons-table-container" style="margin-top: 20px;">
        <!-- The single table of past lessons will be rendered here by JavaScript -->
    </div>
  </section>

  <footer>
    <p>&copy; 2025 C2 Tennis Academy. All rights reserved.</p>
  </footer>

  <script>
  // This script block is intentionally left empty as the form-related JS was removed.
  // New JS logic will be added in the next script tag or by replacing this one.
  </script>

  <script>
// Corrected JavaScript logic provided by the user starts here
let allFetchedPastLessons = []; 
let activeCategoryFilter = 'All'; 
let editing = false;

const validCoaches = [
    "Ricardo Carvajalino",
    "Zach Capone",
    "Jacob Capone",
    "Paula Carvajalino"
];

let enableHistoryEditingBtn;
let saveHistoryBtn;
let historyTableContainer; 

function formatTime_12hr(timeStr) {
  if (!timeStr || !timeStr.includes(':')) { return timeStr; }
  const parts = timeStr.split(':');
  let hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  hours = hours ? hours : 12; 
  const minutesStr = minutes < 10 ? '0' + minutes : minutes;
  return hours + ':' + minutesStr + ' ' + ampm;
}

// Function to convert HH:MM string to total minutes since midnight
function timeToMinutes(timeStr) {
  if (!timeStr || !timeStr.includes(':')) return null;
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
}

// Function to convert total minutes since midnight to HH:MM string (24-hour format)
function minutesToHHMM(totalMinutes) {
  if (totalMinutes === null || isNaN(totalMinutes)) return '';
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}

// New helper function to populate time options
function populateTimeOptions(selectElement, originalTime24hr) {
  selectElement.innerHTML = ''; // Clear existing options

  const startTime = 7 * 60; // 7:00 AM in minutes
  const endTime = 21 * 60; // 9:00 PM in minutes
  const interval = 30; // 30 minutes

  // Add a default empty option
  const defaultOption = document.createElement('option');
  defaultOption.value = "";
  defaultOption.textContent = "-- Select Time --";
  selectElement.appendChild(defaultOption);

  let originalTimeSelected = false;
  for (let minutes = startTime; minutes <= endTime; minutes += interval) {
    const option = document.createElement('option');
    const time24hr = minutesToHHMM(minutes); // HH:MM format for value
    option.value = time24hr;
    option.textContent = formatTime_12hr(time24hr); // H:MM AM/PM format for display

    if (originalTime24hr && time24hr === originalTime24hr) {
      option.selected = true;
      originalTimeSelected = true;
    }
    selectElement.appendChild(option);
  }

  // If the originalTime24hr was something like "15:17" (not an exact 30-min interval)
  // or outside the standard 7 AM - 9 PM range, add it as an option and select it.
  if (originalTime24hr && !originalTimeSelected) {
    const originalOption = document.createElement('option');
    originalOption.value = originalTime24hr;
    originalOption.textContent = formatTime_12hr(originalTime24hr) + " (Custom)"; // Indicate it's custom
    originalOption.selected = true;
    
    // Try to insert it in a sorted manner or append. For simplicity, append or prepend.
    // Prepending makes it more visible if it's an unusual time.
    selectElement.insertBefore(originalOption, selectElement.children[1]); // Insert after "-- Select Time --"
  }
}

// New helper function to generate the entire select element
function generateTimeSelectElement(lessonId, originalTime24hr) {
  const select = document.createElement('select');
  select.className = 'history-time-select';
  select.dataset.id = lessonId;
  // Store original time in HH:MM format. Ensure `les.time` is consistently HH:MM.
  // If `les.time` can be null/undefined, handle it (e.g., default to empty string).
  select.dataset.originalTime = originalTime24hr || ""; 
  select.disabled = !editing; // Use global 'editing' variable state

  populateTimeOptions(select, originalTime24hr || "");

  return select;
}

function renderPastLessonsTable(lessonsArray, containerId, placeholderMessage) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error('Container not found for ID:', containerId);
    return;
  }

  if (lessonsArray.length === 0) {
    container.innerHTML = `<p>${placeholderMessage}</p>`;
    return;
  }

  const isCampProgram = (programName) => {
    if (!programName) return false;
    const lowerProgramName = programName.toLowerCase();
    return lowerProgramName.includes('camp') || lowerProgramName.includes('pass');
  };

  let tableHTML = `
    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
      <thead>
        <tr style="background:#0c3c78; color:white;">
          <th style="padding:8px; border:1px solid #ddd;">Program</th>
          <th style="padding:8px; border:1px solid #ddd;">Coach</th>
          <th style="padding:8px; border:1px solid #ddd;">Date</th>
          <th style="padding:8px; border:1px solid #ddd;">Time</th>
          <th style="padding:8px; border:1px solid #ddd;">Student</th>
          <th style="padding:8px; border:1px solid #ddd;">Email</th>
          <th style="padding:8px; border:1px solid #ddd;">Phone</th>
          <th style="padding:8px; border:1px solid #ddd;">Lesson Cost</th>
          <th style="padding:8px; border:1px solid #ddd;">Referral Source</th>
          <th style="padding:8px; border:1px solid #ddd;">Paid</th>
          <th style="padding:8px; border:1px solid #ddd;">Actions</th>
        </tr>
      </thead>
      <tbody>
  `;

  if (activeCategoryFilter === 'Camps') {
    const groupedLessons = {};
    lessonsArray.forEach(les => {
      // Ensure only camp programs are processed for grouping if this function is ever called directly
      // with mixed data when 'Camps' filter is active. filterAndRenderHistory should pre-filter.
      if (!isCampProgram(les.program)) {
          // Optionally, render as individual row or skip. For now, skip if not camp/pass.
          // console.warn("Non-camp program found in 'Camps' filter:", les);
          return; 
      }

      const originalDate = les.date ? les.date.substring(0, 10) : 'nodate';
      const originalTime = les.time || 'notime';
      const compositeKey = `${les.program}-${originalDate}-${originalTime}`;
      const isLessonPaid = les.paid === true || String(les.paid).toLowerCase() === 'true';

      if (!groupedLessons[compositeKey]) {
        groupedLessons[compositeKey] = {
          program: les.program,
          date: originalDate,
          time: originalTime,
          student: les.student,
          email: les.email,
          phone: les.phone,
          lesson_cost: les.lesson_cost,
          referral_source: les.referral_source || '—',
          coaches: new Set(), // Initialize with a Set for unique coach names
          originalBookingIds: [les.id],
          paid: isLessonPaid, // Initialize paid status with the first lesson's status
          // Store formatted date/time from first lesson for display consistency
          displayDate: les.date ? new Date(les.date).toLocaleDateString() : 'N/A',
          displayTime: les.time ? formatTime_12hr(les.time) : 'N/A',
        };
        const lessonCoaches = [les.coach, les.coach2, les.coach3].filter(Boolean);
        lessonCoaches.forEach(c => groupedLessons[compositeKey].coaches.add(c));
      } else {
        const lessonCoaches = [les.coach, les.coach2, les.coach3].filter(Boolean);
        lessonCoaches.forEach(c => groupedLessons[compositeKey].coaches.add(c));
        groupedLessons[compositeKey].originalBookingIds.push(les.id);
        if (isLessonPaid) { // If any lesson in the group is paid, the group is considered paid
          groupedLessons[compositeKey].paid = true;
        }
        // Student, email, phone, cost, referral_source are assumed to be the same for the group, taken from the first lesson.
      }
    });

    Object.values(groupedLessons).forEach(group => {
      const groupDisplayId = group.originalBookingIds.join('-'); // For checkbox data-id
      const rowDataId = group.originalBookingIds[0]; // Main row data-id, for now use first ID
      const coachesDisplay = Array.from(group.coaches).join(', ');
      // Use stored displayDate/Time, or format from group.date/time if needed
      const dateStr = group.displayDate; 
      const formattedTime = group.displayTime;
      const referralSourceDisplay = group.referral_source || '—';

      tableHTML += `
        <tr data-id="${rowDataId}" 
            data-is-grouped="true" 
            data-original-ids='${JSON.stringify(group.originalBookingIds)}'
            data-program="${group.program || ''}"
            data-date="${group.date || ''}"
            data-time="${group.time || ''}"
            data-student="${group.student || ''}"
            data-email="${group.email || ''}"
            data-phone="${group.phone || ''}"
            data-lesson-cost="${group.lesson_cost !== null && group.lesson_cost !== undefined ? group.lesson_cost : ''}">
          <td class="history-cell" data-id="${rowDataId}" data-field="program" data-original-value="${group.program || ''}" style="padding:8px; border:1px solid #ddd;">${group.program || '—'}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="coach" data-original-value="${coachesDisplay}" style="padding:8px; border:1px solid #ddd;">${coachesDisplay || '—'}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="date" data-original-value="${group.date || ''}" style="padding:8px; border:1px solid #ddd;">${dateStr}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="time" data-original-value="${group.time || ''}" style="padding:8px; border:1px solid #ddd;">${formattedTime}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="student" data-original-value="${group.student || ''}" style="padding:8px; border:1px solid #ddd;">${group.student || '—'}</td>
          <td style="padding:8px; border:1px solid #ddd;">${group.email || '—'}</td>
          <td style="padding:8px; border:1px solid #ddd;">${group.phone || '—'}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="lesson_cost" data-original-value="${group.lesson_cost !== null && group.lesson_cost !== undefined ? group.lesson_cost : ''}" style="padding:8px; border:1px solid #ddd;">${group.lesson_cost !== null && group.lesson_cost !== undefined ? group.lesson_cost : ''}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="referral_source" data-original-value="${referralSourceDisplay}" style="padding:8px; border:1px solid #ddd;">${referralSourceDisplay}</td>
          <td class="history-cell" data-id="${rowDataId}" data-field="paid" data-original-value="${String(group.paid)}" style="padding:8px; border:1px solid #ddd;">${group.paid ? 'Yes' : 'No'}</td>
          <td style="padding:8px; border:1px solid #ddd;">
            <button onclick="deleteAdminLesson(${rowDataId}, true)">Delete Group</button> <!-- Placeholder, needs specific handling for grouped deletion -->
          </td>
        </tr>
      `;
    });

  } else { // Original logic for non-camp views
    lessonsArray.forEach(les => {
      const dateStr = les.date ? new Date(les.date).toLocaleDateString() : 'N/A';
      // const formattedTime = les.time ? formatTime_12hr(les.time) : 'N/A'; // No longer directly used here for non-grouped
      const referralSourceDisplay = les.referral_source || '—';
      const originalDate = les.date ? les.date.substring(0,10) : '';
      const isPaid = les.paid === true || String(les.paid).toLowerCase() === 'true';

      // Placeholder for time select element
      const timeSelectPlaceholderId = `time-select-cell-${les.id}`;
      const coaches = [les.coach, les.coach2, les.coach3].filter(Boolean).join(', ');
      const originalCoachesValue = [les.coach || '', les.coach2 || '', les.coach3 || ''].filter(Boolean).join(', ');

      tableHTML += `
        <tr data-id="${les.id}">
          <td class="history-cell" data-id="${les.id}" data-field="program" data-original-value="${les.program || ''}" style="padding:8px; border:1px solid #ddd;">${les.program || '—'}</td>
          <td class="history-cell" data-id="${les.id}" data-field="coach" data-original-value="${originalCoachesValue}" style="padding:8px; border:1px solid #ddd;">${coaches || '—'}</td>
          <td class="history-cell" data-id="${les.id}" data-field="date" data-original-value="${originalDate}" style="padding:8px; border:1px solid #ddd;">${dateStr}</td>
          <td id="${timeSelectPlaceholderId}" style="padding:8px; border:1px solid #ddd;"></td>
          <td class="history-cell" data-id="${les.id}" data-field="student" data-original-value="${les.student || ''}" style="padding:8px; border:1px solid #ddd;">${les.student || '—'}</td>
          <td style="padding:8px; border:1px solid #ddd;">${les.email || '—'}</td>
          <td style="padding:8px; border:1px solid #ddd;">${les.phone || '—'}</td>
          <td class="history-cell" data-id="${les.id}" data-field="lesson_cost" data-original-value="${les.lesson_cost !== null && les.lesson_cost !== undefined ? les.lesson_cost : ''}" style="padding:8px; border:1px solid #ddd;">${les.lesson_cost !== null && les.lesson_cost !== undefined ? les.lesson_cost : ''}</td>
          <td class="history-cell" data-id="${les.id}" data-field="referral_source" data-original-value="${referralSourceDisplay}" style="padding:8px; border:1px solid #ddd;">${referralSourceDisplay}</td>
          <td class="history-cell" data-id="${les.id}" data-field="paid" data-original-value="${String(isPaid)}" style="padding:8px; border:1px solid #ddd;">${isPaid ? 'Yes' : 'No'}</td>
          <td style="padding:8px; border:1px solid #ddd;">
            <button onclick="deleteAdminLesson(${les.id})">Delete</button>
          </td>
        </tr>
      `;
    });
  }
  tableHTML += `</tbody></table>`;
  container.innerHTML = tableHTML;

  // After table HTML is set, populate the time select cells
  if (activeCategoryFilter !== 'Camps') { // Only do this for non-grouped rows
    lessonsArray.forEach(les => {
      const timeSelectCell = document.getElementById(`time-select-cell-${les.id}`);
      if (timeSelectCell) {
        const timeSelectElement = generateTimeSelectElement(les.id, les.time ? les.time.substring(0,5) : '');
        timeSelectCell.appendChild(timeSelectElement);
      }
    });
  }

}

async function loadHistory() {
  if (!historyTableContainer) historyTableContainer = document.getElementById('past-lessons-table-container');
  historyTableContainer.innerHTML = '<p>Loading history...</p>';
  
  try {
    const res = await fetch('/api/admin/lessons', { credentials: 'include' });
    if (!res.ok) {
      historyTableContainer.innerHTML = '<p style="color:red;">Could not load lesson history data.</p>';
      return;
    }
    const lessons = await res.json();
    const now = new Date();
    const pastLessons = lessons.filter(les => {
      if (!les.date) return false;
      const dateStr = les.date.substring(0, 10);
      const dateParts = dateStr.split('-');
      if (dateParts.length !== 3) return false;
      const year = parseInt(dateParts[0]);
      const month = parseInt(dateParts[1]) - 1;
      const day = parseInt(dateParts[2]);
      let hours = 23, minutes = 59, seconds = 59;
      if (les.time) {
        const timeParts = les.time.split(':');
        if (timeParts.length >= 2) {
          hours = parseInt(timeParts[0]);
          minutes = parseInt(timeParts[1]);
          seconds = timeParts[2] ? parseInt(timeParts[2]) : 0;
        }
      }
      try {
        const lessonDate = new Date(year, month, day, hours, minutes, seconds);
        return lessonDate < now;
      } catch (e) {
        console.error(`Error parsing date for lesson: ${les.id}`, e);
        return false;
      }
    });
    allFetchedPastLessons = [...pastLessons];
    filterAndRenderHistory('');
  } catch (error) {
    console.error('Error loading lesson history:', error);
    historyTableContainer.innerHTML = '<p style="color:red;">Failed to load history due to a network error.</p>';
  }
}

async function deleteAdminLesson(id, isGroup = false) {
  if (isGroup) {
    console.log(`Group deletion initiated for ID (first ID of group): ${id}`);
    const row = document.querySelector(`tr[data-id='${id}']`);

    if (!row) {
      alert('Error: Could not find the lesson row in the table.');
      return;
    }

    const originalIdsJSON = row.getAttribute('data-original-ids');
    let ids;
    try {
      ids = JSON.parse(originalIdsJSON);
      if (!Array.isArray(ids) || ids.length === 0) {
        alert('Error: Could not retrieve or parse original booking IDs for the group.');
        return;
      }
    } catch (e) {
      console.error('Error parsing original booking IDs:', e);
      alert('Error: Could not retrieve or parse original booking IDs for the group.');
      return;
    }

    if (!confirm(`Are you sure you want to delete this entire group? This will delete ${ids.length} booking(s).`)) {
      return;
    }

    try {
      const res = await fetch('/api/admin/lessons/delete-group', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ ids: ids }),
        credentials: 'include',
      });

      if (res.ok) {
        loadHistory();
        alert('Group deleted successfully.');
      } else {
        let errorMessage = 'Group deletion failed.';
        try {
          const errorData = await res.json();
          if (errorData && errorData.message) {
            errorMessage = `Group deletion failed: ${errorData.message}`;
          }
        } catch (e) {
          // Could not parse JSON, use default error or text if available
           const textError = await res.text();
           if(textError) errorMessage = `Group deletion failed: ${textError}`;
        }
        alert(errorMessage);
      }
    } catch (err) {
      console.error('Error deleting group:', err);
      alert('Group deletion failed due to a network error.');
    }

  } else { // Individual lesson deletion
    if (!confirm('Are you sure you want to delete this lesson?')) return;
    try {
      const res = await fetch(`/api/admin/lessons/${id}`, {
        method: 'DELETE',
        credentials: 'include',
      });
      if (res.ok) {
        loadHistory();
      } else {
        let errorText = 'Delete failed.';
        try {
            // Try to parse as JSON first for structured error messages
            const errorData = await res.json();
            if (errorData && errorData.message) {
                errorText = `Delete failed: ${errorData.message}`;
            } else {
                // Fallback to text if not JSON or no message property
                errorText = `Delete failed: ${await res.text()}`;
            }
        } catch (e) {
            // If JSON parsing fails, try to get plain text
            try {
                errorText = `Delete failed: ${await res.text()}`;
            } catch (e2) {
                // If text reading also fails, use a generic message with status
                errorText = `Delete failed with status: ${res.status}`;
            }
        }
        alert(errorText);
      }
    } catch (err) {
      console.error('Error deleting lesson:', err);
      alert('Delete failed due to a network error.');
    }
  }
}

function filterAndRenderHistory(searchTerm) {
  let searchFilteredLessons;
  if (!searchTerm) {
    searchFilteredLessons = [...allFetchedPastLessons];
  } else {
    searchFilteredLessons = allFetchedPastLessons.filter(les => {
      if (!les) return false;
      const dateStr = les.date ? new Date(les.date).toLocaleDateString().toLowerCase() : '';
      return [les.program, les.coach, les.student, les.email, les.phone, dateStr]
        .some(field => field && String(field).toLowerCase().includes(searchTerm));
    });
  }

  let finalDisplayLessons;
  if (activeCategoryFilter === 'All') {
    finalDisplayLessons = [...searchFilteredLessons];
  } else {
    finalDisplayLessons = searchFilteredLessons.filter(les => {
      if (!les || !les.program) return false;
      const programName = les.program.toLowerCase();
      if (activeCategoryFilter === 'Privates') return programName.includes('private');
      if (activeCategoryFilter === 'Camps') return programName.includes('camp') || programName.includes('pass');
      if (activeCategoryFilter === 'Clinics') return programName.includes('clinic') || programName.includes('high performance');
      return false;
    });
  }
  renderPastLessonsTable(finalDisplayLessons, 'past-lessons-table-container', 'No matching past lessons found.');
}

window.addEventListener('DOMContentLoaded', () => {
  enableHistoryEditingBtn = document.getElementById('enable-history-editing-btn');
  saveHistoryBtn = document.getElementById('save-history-btn');
  historyTableContainer = document.getElementById('past-lessons-table-container');

  loadHistory();

  if (enableHistoryEditingBtn) {
    enableHistoryEditingBtn.addEventListener('click', () => {
      editing = !editing;
      enableHistoryEditingBtn.textContent = editing ? 'Disable Editing' : 'Enable Editing';
      if (saveHistoryBtn) saveHistoryBtn.disabled = !editing;

      document.querySelectorAll('.history-cell').forEach(td => {
        const tr = td.closest('tr');
        const isGroupedRow = tr && tr.dataset.isGrouped === 'true';
        const fieldName = td.dataset.field;

        if (isGroupedRow) {
            if (fieldName === 'coach') { // Only coach field is editable for grouped rows
                // For grouped rows, if editing is enabled, create the dropdown.
                // If editing is disabled, revert to text.
                if (editing) {
                    const currentCoachValue = td.innerText.trim();
                    const programType = tr.dataset.program ? tr.dataset.program.toLowerCase() : '';
                    td.innerHTML = ''; // Clear the cell

                    if (programType.includes('camp') || programType.includes('pass')) {
                        // Create a div for checkbox list
                        const coachListContainer = document.createElement('div');
                        coachListContainer.className = 'coach-checkbox-list';
                        coachListContainer.style.display = 'flex';
                        coachListContainer.style.flexWrap = 'wrap';
                        coachListContainer.style.gap = '10px';

                        const selectedCoaches = currentCoachValue.split(',').map(c => c.trim().toLowerCase());
                        validCoaches.forEach(coachName => {
                            const label = document.createElement('label');
                            label.style.display = 'flex';
                            label.style.alignItems = 'center';
                            label.style.gap = '5px';

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.name = 'coach-checkbox';
                            checkbox.value = coachName;
                            if (selectedCoaches.includes(coachName.toLowerCase())) {
                                checkbox.checked = true;
                            }
                            
                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(coachName));
                            coachListContainer.appendChild(label);
                        });
                        td.appendChild(coachListContainer);
                    } else {
                        // Fallback to single select for non-camp/pass grouped rows (if any such case exists)
                        const selectEl = document.createElement('select');
                        selectEl.className = 'history-coach-select';
                        validCoaches.forEach(coachName => {
                            const optionEl = document.createElement('option');
                            optionEl.value = coachName;
                            optionEl.textContent = coachName;
                            // Select first coach if multiple were listed, or the single coach
                            if (coachName === currentCoachValue.split(',')[0].trim()) {
                                optionEl.selected = true;
                            }
                            selectEl.appendChild(optionEl);
                        });
                        td.appendChild(selectEl);
                    }
                    td.contentEditable = false; 
                } else {
                    // When disabling editing for a grouped coach cell
                    const coachListContainer = td.querySelector('.coach-checkbox-list');
                    if (coachListContainer) { // If checkboxes were used
                        const selectedCheckboxes = Array.from(coachListContainer.querySelectorAll('input[type="checkbox"]:checked'));
                        const selectedCoachNames = selectedCheckboxes.map(cb => cb.value);
                        td.innerHTML = ''; // Clear the checkboxes
                        td.textContent = selectedCoachNames.join(', ') || '—';
                    } else { // Fallback for select elements (if program was not camp/pass)
                        const selectEl = td.querySelector('select.history-coach-select');
                        if (selectEl) {
                            // This part remains for single-select dropdowns in grouped rows (non camp/pass)
                            const selectedCoach = selectEl.value;
                            td.innerHTML = ''; 
                            td.textContent = selectedCoach || '—'; 
                        }
                        // If it was a multi-select (older version, or if a non-camp/pass somehow had it), this also needs to be handled
                        // However, current logic only creates multi-select for camp/pass, which are now checkboxes.
                        // So, this 'else' for selectEl should primarily hit single-selects.
                    }
                }
            } else {
                td.contentEditable = false; 
            }
        } else { // Logic for non-grouped rows
            // Coach field will now be handled by the generic contentEditable logic below
            if (fieldName === 'referral_source') { // Keep referral_source special handling
            td.contentEditable = false; // It's a select, not directly editable
            if (editing) {
              const originalValue = td.dataset.originalValue === '—' ? '' : td.dataset.originalValue;
              td.innerHTML = '';
              const selectEl = document.createElement('select');
              selectEl.className = 'history-referral-select';
              const options = [
                  { value: '', text: 'None' },
                  { value: 'Ricardo', text: 'Referred by Ricardo' },
                  { value: 'Jacob', text: 'Jacob - Own Booking' },
                  { value: 'Paula', text: 'Paula - Own Booking' },
                  { value: 'Zach', text: 'Zach - Own Booking' },
                  { value: 'RicardoOwn', text: 'Ricardo - Teaches Himself' }
              ];
              options.forEach(opt => {
                const optionEl = document.createElement('option');
                optionEl.value = opt.value;
                optionEl.textContent = opt.text;
                if (opt.value === originalValue) optionEl.selected = true;
                selectEl.appendChild(optionEl);
              });
              td.appendChild(selectEl);
            } else {
              const selectEl = td.querySelector('select.history-referral-select');
              if (selectEl) {
                const selectedText = selectEl.options[selectEl.selectedIndex]?.text || selectEl.value;
                td.innerHTML = '';
                td.textContent = selectedText || '—';
              }
            }
          } else if (fieldName === 'coach') {
            if (editing) {
              const currentCellText = td.innerText.trim();
              // Determine the first coach's name. Fallback to an empty string or first valid coach if needed.
              let firstCoachName = '';
              if (currentCellText && currentCellText !== '—') {
                firstCoachName = currentCellText.split(',')[0].trim();
              } else if (validCoaches.length > 0) {
                // Optional: fallback to the first valid coach if cell is empty and that's desired.
                // firstCoachName = validCoaches[0]; // Uncomment if this behavior is needed.
              }

              td.innerHTML = ''; // Clear the cell's current content.

              const selectEl = document.createElement('select');
              selectEl.className = 'history-coach-select'; // Reuse class if appropriate or define new one

              validCoaches.forEach(coachName => {
                const optionEl = document.createElement('option');
                optionEl.value = coachName;
                optionEl.textContent = coachName;
                if (coachName === firstCoachName) {
                  optionEl.selected = true;
                }
                selectEl.appendChild(optionEl);
              });

              td.appendChild(selectEl);
              td.contentEditable = false; // Ensure contentEditable is false as we are using a select.
            } else {
              // Disabling editing for the coach cell
              const selectEl = td.querySelector('select.history-coach-select');
              if (selectEl) {
                const selectedCoachName = selectEl.value;
                td.innerHTML = ''; // Clear the select element.
                td.innerText = selectedCoachName || '—'; // Set text to selected coach or '—' if empty.
              }
              // td.contentEditable = false; // Should remain false or be explicitly set if needed.
            }
          } else { // For other editable cells in non-grouped rows
            td.contentEditable = editing;
            if (!editing) td.blur();
          }
        }
      });

      // Add this part:
      document.querySelectorAll('select.history-time-select').forEach(select => {
        select.disabled = !editing;
      });
    });
  }

  if (saveHistoryBtn) {
    saveHistoryBtn.addEventListener('click', async () => {
      if (!confirm('Are you sure you want to save all changes to the history?')) return;
      if (enableHistoryEditingBtn) enableHistoryEditingBtn.disabled = true;
      saveHistoryBtn.disabled = true;

      const updates = [];
      const groupedUpdates = [];

      document.querySelectorAll('.history-cell[data-id]').forEach(td => {
        const tr = td.closest('tr');
        const isGroupedRow = tr && tr.dataset.isGrouped === 'true';
        const bookingId = td.dataset.id; // This is the first booking ID for grouped rows
        const fieldName = td.dataset.field;
        const originalValue = td.dataset.originalValue;
        let newValue;
        let changed = false;

        if (isGroupedRow) {
          // Updated handling for grouped rows coach saving
          if (fieldName === 'coach') {
            const checkboxes = td.querySelectorAll('input[type="checkbox"][name="coach-checkbox"]');
            let selectedCoaches = []; // Initialize here to ensure it's always an array

            if (checkboxes.length > 0) { // Check if checkboxes are present (Camp/Pass row)
              checkboxes.forEach(cb => {
                if (cb.checked) selectedCoaches.push(cb.value);
              });

              const originalCoachesArray = originalValue
                .split(',')
                .map(name => name.trim())
                .filter(name => name);

              const originalSet = new Set(originalCoachesArray.sort());
              const selectedSet = new Set(selectedCoaches.sort());

              if (originalCoachesArray.length !== selectedCoaches.length ||
                  !originalCoachesArray.every(coach => selectedSet.has(coach)) ||
                  !selectedCoaches.every(coach => originalSet.has(coach)) ) {
                changed = true;
              }
              // newValue is implicitly selectedCoaches here for the changed check and data push
            } else {
              // This is a grouped row, but not a Camp/Pass (e.g., uses a single select for coach)
              const selectEl = td.querySelector('select.history-coach-select');
              if (selectEl) {
                newValue = selectEl.value; // This is the single selected coach
                const originalCoachesArray = originalValue.split(',').map(name => name.trim()).filter(name => name);
                const firstOriginalCoach = originalCoachesArray[0] || '';

                // A single select value is considered changed if it's different from the first original coach,
                // or if the original had multiple coaches (implying a consolidation),
                // or if the original was empty and now a coach is selected.
                if (newValue !== firstOriginalCoach || originalCoachesArray.length > 1 || (originalCoachesArray.length === 0 && newValue !== '')) {
                  changed = true;
                }
                if (changed) {
                  selectedCoaches = [newValue]; // Ensure selectedCoaches is an array for the data push
                } else {
                  // If not changed, selectedCoaches should reflect the original state for this path
                  // or remain empty if no change and no original value.
                  // However, newCoaches in groupedUpdates will only be populated if changed is true.
                  selectedCoaches = originalCoachesArray; // Keep original if no change
                }
              }
            }

            if (changed) {
              try {
                const originalBookingIds = JSON.parse(tr.dataset.originalIds);
                groupedUpdates.push({
                  program: tr.dataset.program,
                  date: tr.dataset.date,
                  time: tr.dataset.time,
                  originalBookingIds: originalBookingIds,
                  newCoaches: selectedCoaches, // selectedCoaches is already an array
                  lesson_cost: parseFloat(tr.dataset.lessonCost) || 0,
                  student: tr.dataset.student,
                  email: tr.dataset.email,
                  phone: tr.dataset.phone,
                  originalCoachValueForDebug: originalValue,
                  newCoachValueForDebug: selectedCoaches.join(', ')
                });
              } catch (e) {
                console.error("Error processing grouped update for coach:", e, tr.dataset.originalIds);
                changed = false;
              }
            }
          }
          // Other fields in grouped rows are not processed for saving as they are not editable
        } else { // Logic for non-grouped rows
          let cellValueChanged = false;
          let processedNewValue;

          if (fieldName === 'coach') {
            const selectEl = td.querySelector('select.history-coach-select');
            if (selectEl) { // Editing is active for this cell, read from select
                processedNewValue = selectEl.value;
            } else { // Editing was disabled, cell is plain text
                processedNewValue = td.innerText.trim();
            }
            // Ensure originalValue is a string before splitting
            const firstOriginalCoach = ((originalValue || '').split(',')[0] || '').trim();
            if (processedNewValue !== firstOriginalCoach) {
                cellValueChanged = true;
            }
          } else if (fieldName === 'referral_source') { // Dropdown, not contentEditable
            const selectEl = td.querySelector('select.history-referral-select');
            if (selectEl) {
              processedNewValue = selectEl.value;
              const normalizedOriginalValue = originalValue === '—' ? '' : originalValue;
              if (processedNewValue !== normalizedOriginalValue) cellValueChanged = true;
            }
          } else if (td.contentEditable === 'true') { // For other directly editable fields
            processedNewValue = td.innerText.trim();
            
            // Type-specific processing
            if (fieldName === 'time') { 
              if (processedNewValue === '' || processedNewValue.toLowerCase() === 'n/a') processedNewValue = null;
            } else if (fieldName === 'program' || fieldName === 'student') { 
              if (processedNewValue === '' || processedNewValue.toLowerCase() === 'null') processedNewValue = null;
            } else if (fieldName === 'date' && td.innerText.includes('/')) {
              const parts = processedNewValue.split('/');
              if (parts.length === 3) processedNewValue = `${parts[2]}-${parts[0].padStart(2, '0')}-${parts[1].padStart(2, '0')}`;
            } else if (fieldName === 'lesson_cost') {
              processedNewValue = processedNewValue.replace('$', '').trim();
              if (processedNewValue === '' && originalValue !== '') processedNewValue = null;
              else if (processedNewValue !== '' && isNaN(Number(processedNewValue))) {
                console.warn(`Invalid cost for booking ${bookingId}: ${processedNewValue}. Skipping update.`);
                return; // Skip this cell's update
              } else if (processedNewValue !== '') {
                processedNewValue = Number(processedNewValue); 
              }
            } else if (fieldName === 'paid') {
              const lowerNewValue = processedNewValue.toLowerCase();
              processedNewValue = (lowerNewValue === 'yes' || lowerNewValue === 'true');
            }
            // General change check for these other fields
            if (String(processedNewValue) !== String(originalValue)) cellValueChanged = true;
          }

          if (cellValueChanged) {
            if (fieldName === 'coach') { // For non-grouped rows, coach field
                updates.push({
                    bookingId: bookingId,
                    fieldName: 'coach', // Explicitly 'coach'
                    newValue: processedNewValue, // The single selected coach
                    originalValueForDebug: originalValue // The full original string "CoachA, CoachB"
                });
            } else { // For all other fields in non-grouped rows
              updates.push({ bookingId, fieldName, newValue: processedNewValue, originalValueForDebug: originalValue });
            }
          }
        }
      });

      // Time select processing needs to be separate as it's not a .history-cell
      document.querySelectorAll('select.history-time-select').forEach(select => {
        const bookingId = select.dataset.id;
        const originalTime = select.dataset.originalTime; // Should be HH:MM
        let newValue = select.value; // Value from select is HH:MM

        // Handle cases where "-- Select Time --" (empty value) might be chosen
        if (newValue === "") {
          newValue = null; // Or whatever the backend expects for clearing a time
        }

        // Compare newValue with originalTime.
        // Note: If originalTime was an empty string from dataset and newValue is null,
        // they might not be strictly equal. Adjust comparison if needed.
        // For example, treat empty string and null as equivalent for "no change".
        const hasChanged = (newValue === null && originalTime !== "") || 
                           (newValue !== null && newValue !== originalTime) ||
                           (newValue === null && originalTime === "") || // Handles case where original was empty and new is null (no change)
                           (newValue !== originalTime); // General case for actual change

        // Refined hasChanged logic:
        // A change occurs if:
        // 1. New value is null AND original time was not an empty string (it was set, now cleared)
        // 2. New value is not null AND it's different from originalTime
        // This logic needs to be careful about (null vs "")
        let trulyChanged = false;
        if (newValue === null) { // User selected "-- Select Time --" or it was programmatically set to null
            if (originalTime !== "" && originalTime !== null) { // Original time was actually set
                trulyChanged = true;
            }
        } else { // User selected a specific time
            if (newValue !== originalTime) {
                trulyChanged = true;
            }
        }

        if (trulyChanged) {
          updates.push({
            bookingId: bookingId,
            fieldName: 'time',
            newValue: newValue, // This will be HH:MM string or null
            originalValueForDebug: originalTime
          });
        }
      });

      if (updates.length === 0 && groupedUpdates.length === 0) {
        alert('No actual changes detected to save.');
        if (enableHistoryEditingBtn) enableHistoryEditingBtn.disabled = false;
        if (editing) saveHistoryBtn.disabled = false;
        else saveHistoryBtn.disabled = true;
        return;
      }

      let successes = 0;
      let failures = 0;
      const failureDetails = [];

      // Process individual updates
      for (const upd of updates) {
        try {
          const res = await fetch(`/api/admin/history/${upd.bookingId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'Credentials': 'include' },
            body: JSON.stringify({ field: upd.fieldName, value: upd.newValue })
          });
          if (res.ok) {
            successes++;
          } else {
            failures++;
            const errData = await res.json().catch(() => ({ message: `Update failed for ID ${upd.bookingId}, Field ${upd.fieldName} with status ${res.status}` }));
            failureDetails.push(`Individual: ${errData.message || `Failed for ${upd.fieldName}`}`);
          }
        } catch (networkError) {
          failures++;
          failureDetails.push(`Individual Network error for ID ${upd.bookingId}, Field ${upd.fieldName}: ${networkError.message}`);
        }
      }

      // Process grouped updates
      for (const groupUpd of groupedUpdates) {
        try {
          const res = await fetch('/api/admin/lessons/update-coaches', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Credentials': 'include' },
            body: JSON.stringify(groupUpd)
          });
          if (res.ok) {
            successes++;
          } else {
            failures++;
            const errData = await res.json().catch(() => ({ message: `Group update failed for program ${groupUpd.program} on ${groupUpd.date} with status ${res.status}` }));
            failureDetails.push(`Group: ${errData.message || `Failed for ${groupUpd.program} on ${groupUpd.date}`}`);
          }
        } catch (networkError) {
          failures++;
          failureDetails.push(`Group Network error for program ${groupUpd.program} on ${groupUpd.date}: ${networkError.message}`);
        }
      }

      let summaryMessage = `${successes} update(s) successful.`;
      if (failures > 0) summaryMessage += `\n${failures} updates failed.\nDetails:\n${failureDetails.join('\n')}`;
      alert(summaryMessage);

      editing = false;
      if (enableHistoryEditingBtn) {
        enableHistoryEditingBtn.disabled = false;
        enableHistoryEditingBtn.textContent = 'Enable Editing';
      }
      if (saveHistoryBtn) saveHistoryBtn.disabled = true;
      document.querySelectorAll('.history-cell').forEach(cell => cell.contentEditable = false);
      loadHistory();
    });
  }

  const bulkCostUpdateButton = document.querySelector('.bulk-update-costs-btn');
  if (bulkCostUpdateButton) {
    // This button seems to be for a different bulk update type (costs from inputs, not general actions)
    // Its existing logic (handleBulkUpdatePrices) should be preserved if it's still meant to function.
    // For now, I'm assuming its event listener setup is separate or handled by its own function.
    // If it was meant to be the `bulkUpdateButton` for checkbox actions, this needs clarification.
    // The original prompt mentioned adding a new button with ID "bulkUpdateButton".
    // The existing button with class "bulk-update-costs-btn" might be different.
    // The provided code has `bulkUpdateButton = document.getElementById('bulkUpdateButton');`
    // and its event listener. The `handleBulkUpdatePrices` and its button seems distinct.
  }

  const searchInput = document.getElementById('historySearchInput');
  if (searchInput) {
    searchInput.addEventListener('input', () => {
      filterAndRenderHistory(searchInput.value.toLowerCase().trim());
    });
  }

  const filterButtons = document.querySelectorAll('#category-filters .category-filter-button');
  filterButtons.forEach(button => {
    button.addEventListener('click', () => {
      activeCategoryFilter = button.getAttribute('data-category');
      filterButtons.forEach(btn => btn.classList.remove('active-filter-button'));
      button.classList.add('active-filter-button');
      filterAndRenderHistory(searchInput ? searchInput.value.toLowerCase().trim() : '');
    });
  });
});
// Corrected JavaScript logic provided by the user ends here
</script>
  <script>
  // This entire block is for mobile menu and session management, remains unchanged.
  document.addEventListener('DOMContentLoaded', () => {
      const menuToggle = document.querySelector('.mobile-menu-toggle');
      const mobileMenuClose = document.querySelector('.mobile-menu-close');
      const mainNav = document.querySelector('nav.main-navigation');

      if (menuToggle && mainNav && mobileMenuClose) {
          menuToggle.addEventListener('click', () => {
              const isMenuOpen = mainNav.classList.toggle('mobile-menu--open');
              menuToggle.setAttribute('aria-expanded', isMenuOpen);
              if (isMenuOpen) {
                  menuToggle.innerHTML = '&times;'; 
                  menuToggle.setAttribute('aria-label', 'Close navigation menu');
              } else {
                  menuToggle.innerHTML = '&#9776;'; 
                  menuToggle.setAttribute('aria-label', 'Open navigation menu');
              }
          });
          mobileMenuClose.addEventListener('click', () => {
              mainNav.classList.remove('mobile-menu--open');
              if (menuToggle) {
                 menuToggle.setAttribute('aria-expanded', 'false');
                 menuToggle.innerHTML = '&#9776;'; 
                 menuToggle.setAttribute('aria-label', 'Open navigation menu');
              }
          });
      }
      const mobileNavLinks = document.querySelectorAll('.mobile-menu-container a');
      if (mainNav && mobileNavLinks.length > 0) {
          mobileNavLinks.forEach(link => {
              link.addEventListener('click', () => {
                  if (mainNav.classList.contains('mobile-menu--open')) {
                      mainNav.classList.remove('mobile-menu--open');
                      if (menuToggle) {
                          menuToggle.setAttribute('aria-expanded', 'false');
                          menuToggle.innerHTML = '&#9776;';
                          menuToggle.setAttribute('aria-label', 'Open navigation menu');
                      }
                  }
              });
          });
      }
      async function checkSession() {
          const existingGreeting = document.querySelector('.welcome-greeting');
          if (existingGreeting) existingGreeting.remove();
          try {
              const res = await fetch('/api/check-session', { credentials: 'include' });
              const data = await res.json(); 
              const authContainerDesktop = document.getElementById('authContainerDesktop');
              const authContainerMobile = document.getElementById('authContainerMobile');
              if (data && data.loggedIn === true && data.isAdmin === true) {
                  const portalButtonText = data.firstName ? 'Admin (' + data.firstName + ')' : 'Admin Portal';
                  const loggedInHTML = '<a href="admin.html"><button>' + portalButtonText + '</button></a><button onclick="logout()">Logout</button>';
                  const loggedInMobileHTML = loggedInHTML; 
                  if (authContainerDesktop) authContainerDesktop.innerHTML = loggedInHTML;
                  if (authContainerMobile) authContainerMobile.innerHTML = loggedInMobileHTML;
                  const welcomeMessageText = data.firstName ? 'Welcome, ' + data.firstName + '!' : 'Welcome, Admin!';
                  const greeting = document.createElement('div');
                  greeting.className = 'welcome-greeting';
                  greeting.textContent = welcomeMessageText;
                  greeting.style.cssText = 'background:#0c3c78;color:white;padding:10px;text-align:center;font-weight:bold;';
                  const existingGreeting = document.querySelector('.welcome-greeting');
                  if (existingGreeting) existingGreeting.remove();
                  if(document.body.firstChild) { 
                      document.body.insertBefore(greeting, document.body.firstChild);
                  } else { 
                      document.body.appendChild(greeting);
                  }
              } else {
                  window.location.href = 'login.html'; 
                  const loggedOutHTML = `<a href="login.html"><button>Login</button></a>`;
                  if (authContainerDesktop) authContainerDesktop.innerHTML = loggedOutHTML;
                  if (authContainerMobile) authContainerMobile.innerHTML = loggedOutHTML;
              }
          } catch (err) {
              console.error('Session check failed, redirecting to login:', err);
              window.location.href = 'login.html'; 
              const authContainerDesktop = document.getElementById('authContainerDesktop');
              const authContainerMobile = document.getElementById('authContainerMobile');
              const loggedOutHTML = `<a href="login.html"><button>Login</button></a>`;
              if (authContainerDesktop) authContainerDesktop.innerHTML = loggedOutHTML;
              if (authContainerMobile) authContainerMobile.innerHTML = loggedOutHTML;
          }
      }
      window.logout = function() { 
          fetch('/api/logout', { method: 'POST', credentials: 'include' })
              .then(() => {
                  const existingGreeting = document.querySelector('.welcome-greeting');
                  if (existingGreeting) existingGreeting.remove();
                  document.cookie = "userFirstName=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                  window.location.href = 'login.html'; 
              });
      }
      checkSession(); 
  });
  </script>
</body>
</html>